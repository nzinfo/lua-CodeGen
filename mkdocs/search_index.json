{
    "docs": [
        {
            "location": "/",
            "text": "lua-CodeGen\n\n\n\n\nPerfection is achieved, not when there is nothing more to add,\nbut when there is nothing left to take away.\n\n \u2014 Antoine de Saint-Exup\u00e9ry\n\n\n\n\nOverview\n\n\n\n\n\nlua-CodeGen is a \"safe\" template engine.\n\n\nlua-CodeGen enforces a strict Model-View separation. Only 4 primitives are supplied :\n\n\n\n\nattribute reference,\n\n\ntemplate include,\n\n\nconditional include,\n\n\nand template application (i.e., \nmap\n operation).\n\n\n\n\nlua-CodeGen allows to split template in small chunk,\nand encourages the reuse of them by inheritance.\n\n\nEach chunk of template is like a rule of a grammar for an \nunparser generator\n.\n\n\nlua-CodeGen is not dedicated to HTML, it could generate any kind of textual code.\n\n\nReferences\n\n\nThe Terence Parr's articles :\n\n\n\n\nEnforcing Strict Model-View Separation in Template Engines\n\n\nA Functional Language For Generating Structured Text\n\n\n\n\nNote : lua-CodeGen is not a port of Terence Parr's\n\nStringTemplate\n.\n\n\nLust\n is another Lua module based on\n\nStringTemplate\n.\n\n\nStatus\n\n\nlua-CodeGen is in beta stage.\n\n\nIt's developed for Lua 5.1, 5.2 & 5.3.\n\n\nDownload\n\n\nlua-CodeGen source can be downloaded from\n\nGitHub\n.\n\n\nInstallation\n\n\nTwo variants are available, a pure Lua without dependency and a\n\nLPeg\n based.\n\n\nlua-CodeGen is available via LuaRocks:\n\n\nluarocks install lua-codegen\n# luarocks install lua-codegen-lpeg\n\n\n\n\nor manually, with:\n\n\nmake install.lua\n# make install.lpeg\n\n\n\n\nTest\n\n\nThe test suite requires the module\n\nlua-TestMore\n.\n\n\nmake test.lua\n# make test.lpeg\n\n\n\n\nCopyright and License\n\n\nCopyright \u00a9 2010-2014 Fran\u00e7ois Perrad\n\n\n\n\n\nThis library is licensed under the terms of the MIT/X11 license,\nlike Lua itself.",
            "title": "Home"
        },
        {
            "location": "/#lua-codegen",
            "text": "Perfection is achieved, not when there is nothing more to add,\nbut when there is nothing left to take away.  \u2014 Antoine de Saint-Exup\u00e9ry",
            "title": "lua-CodeGen"
        },
        {
            "location": "/#overview",
            "text": "lua-CodeGen is a \"safe\" template engine.  lua-CodeGen enforces a strict Model-View separation. Only 4 primitives are supplied :   attribute reference,  template include,  conditional include,  and template application (i.e.,  map  operation).   lua-CodeGen allows to split template in small chunk,\nand encourages the reuse of them by inheritance.  Each chunk of template is like a rule of a grammar for an  unparser generator .  lua-CodeGen is not dedicated to HTML, it could generate any kind of textual code.",
            "title": "Overview"
        },
        {
            "location": "/#references",
            "text": "The Terence Parr's articles :   Enforcing Strict Model-View Separation in Template Engines  A Functional Language For Generating Structured Text   Note : lua-CodeGen is not a port of Terence Parr's StringTemplate .  Lust  is another Lua module based on StringTemplate .",
            "title": "References"
        },
        {
            "location": "/#status",
            "text": "lua-CodeGen is in beta stage.  It's developed for Lua 5.1, 5.2 & 5.3.",
            "title": "Status"
        },
        {
            "location": "/#download",
            "text": "lua-CodeGen source can be downloaded from GitHub .",
            "title": "Download"
        },
        {
            "location": "/#installation",
            "text": "Two variants are available, a pure Lua without dependency and a LPeg  based.  lua-CodeGen is available via LuaRocks:  luarocks install lua-codegen\n# luarocks install lua-codegen-lpeg  or manually, with:  make install.lua\n# make install.lpeg",
            "title": "Installation"
        },
        {
            "location": "/#test",
            "text": "The test suite requires the module lua-TestMore .  make test.lua\n# make test.lpeg",
            "title": "Test"
        },
        {
            "location": "/#copyright-and-license",
            "text": "Copyright \u00a9 2010-2014 Fran\u00e7ois Perrad   This library is licensed under the terms of the MIT/X11 license,\nlike Lua itself.",
            "title": "Copyright and License"
        },
        {
            "location": "/codegen/",
            "text": "CodeGen\n\n\n\n\nManual\n\n\nFor the impatient\n\n\nlocal CodeGen = require 'CodeGen'\n\ntmpl = CodeGen {    -- instanciation\n    tarball = \"${name}-${version}.tar.gz\",\n    name = 'lua',\n}\ntmpl.version = 5.1\noutput = tmpl 'tarball'     -- interpolation\nprint(output) --> lua-5.1.tar.gz\n\n\n\n\nThe instanciation\n\n\nThe instanciation of a template is done by the call of \nCodeGen\n\nwith optional parameters. This first parameter is a table.\nThis table uses only string as key and could contains 3 kinds of value :\n\n\n\n\nchunk of template which is a string\nand could contains primitives i.e. \n${...}\n\n\ndata which gives access to the data model\n\n\nformatter which is a function which accepts a string\nas parameter and returns it after a transformation.\nThe typical usage is for escape sequence.\n\n\n\n\nThe other parameters allow inheritance (ie. access to field)\nfrom other templates or simple tables.\n\n\nA common pattern is to put this step in an external file.\n\n\n-- file: tarball.tmpl\nreturn CodeGen {\n    tarball = \"${name}-${version}.tar.gz\",\n}\n\n\n\n\ntmpl = dofile 'tarball.tmpl'\n\n\n\n\nSetting data and other alteration\n\n\nAfter the instanciation and before the interpolation,\nall member of the template are accessible and modifiable like in a table.\n\n\nTypically, data from the model are added after the instanciation.\n\n\nThe interpolation\n\n\nThe interpolation is done by calling the template with one string parameter\nwhich is the keyname of the entry point template.\n\n\nThe interpolation returns a string as result\nand an optional string which contains some error messages.\n\n\nThe 4 primitives in template\n\n\nThe \ndata\n could be in the form of \nfoo.bar.baz\n.\n\n\n1. Attribute reference\n\n\nThe syntax is \n${data[; separator='sep'][; format=name]}\n.\n\n\nAn undefined \ndata\n produces an empty string.\n\n\nThe option \nformat\n allows to specify a formatter function,\nwhich is a value of the template referred by the key \nname\n.\nThe default behavior is given by the standard Lua function \ntostring\n.\n\n\nWhen \ndata\n is a table, the option \nseparator\n is used\nas parameter of \ntable.concat(data, sep)\n.\nThis parameter could be simple quoted or double quoted,\nand it handles escape sequence like Lua.\nThe characters \n{\n and \n}\n are forbidden,\nthere must be represented by a decimal escape sequence \n\\ddd\n.\n\n\nlocal CodeGen = require 'CodeGen'\n\ntmpl = CodeGen {\n    call = \"${name}(${parameters; separator=', '});\",\n}\ntmpl.name = 'print'\ntmpl.parameters = { 1, 2, 3 }\noutput = tmpl 'call'\nprint(output) --> print(1, 2, 3);\n\n\n\n\n2. Template include\n\n\nThe syntax is \n${name()}\n where \nname\n is the keyname of a chunk template.\n\n\nIf \nname\n is not the keyname of a valid chunk,\nthere are no substitution and an error is reported.\n\n\n3. Conditional include\n\n\nThe \nif\n syntax is \n${data?name1()}\n\nand the \nif/else\n syntax is \n${data?name1()!name2()}\n\nwhere \nname1\n and \nname2\n are the keyname of a chunk template\nand \ndata\n is evaluated as a boolean.\n\n\n4. Template application\n\n\nThe syntax is \n${data/name()[; separator='sep']}\n\nwhere \ndata\n must be a table.\nThe template \nname\n is called for each item of the array \ndata\n,\nand the result is concatened with an optional \nseparator\n.\n\n\nThe template has a direct access in the item,\nand inherits access from the caller.\nIf the item is not a table, it is accessible via the key \nit\n.\n\n\nExamples\n\n\n99 Bottles of Beer\n\n\nYet another generation of the song\n\n99 Bottles of Beer\n.\n\n\nlocal CodeGen = require 'CodeGen'\n\nlocal function bootle (n)\n    if n == 0 then\n        return 'No more bottles of beer'\n    elseif n == 1 then\n        return '1 bottle of beer'\n    else\n        return tostring(n) .. ' bottles of beer'\n    end\nend\n\nlocal function action (n)\n    if n == 0 then\n        return 'Go to the store and buy some more'\n    else\n        return 'Take one down and pass it around'\n    end\nend\n\nlocal function populate ()\n    local t = {}\n    for i = 99, 0, -1 do\n        table.insert(t, i)\n    end\n    return t\nend\n\nlocal tmpl = CodeGen {\n    numbers = populate(),       -- { 99, 98, ..., 1, 0 }\n    lyrics = [[\n${numbers/stanza(); separator='\\n'}\n]],\n    stanza = [[\n${it; format=bootle} on the wall, ${it; format=bootle_lower}.\n${it; format=action}, ${it; format=bootle_next} on the wall.\n]],\n    bootle = bootle,\n    bootle_lower = function (n)\n        return bootle(n):lower()\n    end,\n    bootle_next = function (n)\n        return bootle((n == 0) and 99 or (n - 1)):lower()\n    end,\n    action = action,\n}\n\nprint(tmpl 'lyrics')            -- let's sing the song\n\n\n\n\nJava class\n\n\nJava getter/setter generation with external template:\n\n\n-- file: java.tmpl\n\nreturn require'CodeGen'{\n    class = [[\npublic class ${_name} {\n    ${_attrs/decl()}\n\n    ${_attrs/getter_setter(); separator='\\n'}\n}\n]],\n    decl = [[\nprivate ${_type} ${_name};\n]],\n    getter_setter = [[\npublic void set${_name; format=firstuc}(${_type} ${_name}) {\n    this.${_name} = ${_name};\n}\npublic ${_type} get${_name; format=firstuc}() {\n    return this.${_name};\n}\n]],\n    firstuc = function (s)\n        return s:sub(1, 1):upper() .. s:sub(2)\n    end,\n}\n\n\n\n\nlocal tmpl = dofile 'java.tmpl' -- load the template\n\n-- populate with data\ntmpl._name = 'Person'\ntmpl._attrs = {\n    { _name = 'name',       _type = 'String' },\n    { _name = 'age',        _type = 'Integer' },\n    { _name = 'address',    _type = 'String' },\n}\n\nprint(tmpl 'class')     -- interpolation\n\n\n\n\nThe output is :\n\n\npublic class Person {\n    private String name;\n    private Integer age;\n    private String address;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return this.name;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n    public Integer getAge() {\n        return this.age;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n    public String getAddress() {\n        return this.address;\n    }\n}\n\n\n\n\nRockspec\n\n\nA generic template for rockspec.\n\n\n-- file: rockspec.tmpl\nreturn CodeGen {\n    rockspec = [[\npackage = '${name}'\nversion = '${version}-${revision}'\n${_source()}\n${_description()}\n${_dependencies()}\n]],\n    _source = [[\nsource = {\n    url = ${_url()},\n    md5 = '${md5}',\n    dir = '${name}-${version}',\n},\n]],\n    _description = [[\ndescription = {\n    ${desc.summary?_summary()}\n    ${desc.homepage?_homepage()}\n    ${desc.maintainer?_maintainer()}\n    ${desc.license?_license()}\n},\n]],\n    _summary = 'summary = \"${desc.summary}\",',\n    _homepage = 'homepage = \"${desc.homepage}\",',\n    _maintainer = 'maintainer = \"${desc.maintainer}\",',\n    _license = 'license = \"${desc.license}\",',\n    _dependencies = [[\ndependencies = {\n${dependencies/_depend()}\n}\n]],\n    _depend = [[\n    '${name} >= ${version}',\n]],\n}\n\n\n\n\nA specialization for all my projects.\n\n\n-- file: my_rockspec.tmpl\nlocal parent = dofile 'rockspec.tmpl'\n\nreturn CodeGen({\n    lower = string.lower,\n    _tarball = \"${name; format=lower}-${version}.tar.gz\",\n    _url = \"'http://cloud.github.com/downloads/fperrad/${name}/${_tarball()}'\",\n    _homepage = 'homepage = \"http://fperrad.github.com/${name}\",',\n    desc = {\n        homepage = true,\n        maintainer = \"Francois Perrad\",\n        license = \"MIT/X11\",\n    },\n}, parent)\n\n\n\n\nAnd finally, an use for this project.\n\n\nCodeGen = require 'CodeGen'\n\nlocal rs = dofile 'my_rockspec.tmpl'\nrs.name = 'lua-CodeGen'\nrs.version = '0.1.0'\nrs.revision = 1\nrs.md5 = 'XxX'\nrs.desc.summary = \"a template engine\"\nrs.dependencies = {\n    { name = 'lua', version = 5.1 },\n    { name = 'lua-testmore', version = '0.2.1' },\n}\nprint(rs 'rockspec')\n\n\n\n\nThe output is :\n\n\npackage = 'lua-CodeGen'\nversion = '0.1.0-1'\nsource = {\n    url = 'http://cloud.github.com/downloads/fperrad/lua-CodeGen/lua-codegen-0.1.0.tar.gz',\n    md5 = 'XxX',\n    dir = 'lua-CodeGen-0.1.0',\n},\ndescription = {\n    summary = \"a template engine\",\n    homepage = \"http://fperrad.github.com/lua-CodeGen\",\n    maintainer = \"Francois Perrad\",\n    license = \"MIT/X11\",\n},\ndependencies = {\n    'lua >= 5.1',\n    'lua-testmore >= 0.2.1',\n}",
            "title": "CodeGen"
        },
        {
            "location": "/codegen/#codegen",
            "text": "",
            "title": "CodeGen"
        },
        {
            "location": "/codegen/#manual",
            "text": "",
            "title": "Manual"
        },
        {
            "location": "/codegen/#for-the-impatient",
            "text": "local CodeGen = require 'CodeGen'\n\ntmpl = CodeGen {    -- instanciation\n    tarball = \"${name}-${version}.tar.gz\",\n    name = 'lua',\n}\ntmpl.version = 5.1\noutput = tmpl 'tarball'     -- interpolation\nprint(output) --> lua-5.1.tar.gz",
            "title": "For the impatient"
        },
        {
            "location": "/codegen/#the-instanciation",
            "text": "The instanciation of a template is done by the call of  CodeGen \nwith optional parameters. This first parameter is a table.\nThis table uses only string as key and could contains 3 kinds of value :   chunk of template which is a string\nand could contains primitives i.e.  ${...}  data which gives access to the data model  formatter which is a function which accepts a string\nas parameter and returns it after a transformation.\nThe typical usage is for escape sequence.   The other parameters allow inheritance (ie. access to field)\nfrom other templates or simple tables.  A common pattern is to put this step in an external file.  -- file: tarball.tmpl\nreturn CodeGen {\n    tarball = \"${name}-${version}.tar.gz\",\n}  tmpl = dofile 'tarball.tmpl'",
            "title": "The instanciation"
        },
        {
            "location": "/codegen/#setting-data-and-other-alteration",
            "text": "After the instanciation and before the interpolation,\nall member of the template are accessible and modifiable like in a table.  Typically, data from the model are added after the instanciation.",
            "title": "Setting data and other alteration"
        },
        {
            "location": "/codegen/#the-interpolation",
            "text": "The interpolation is done by calling the template with one string parameter\nwhich is the keyname of the entry point template.  The interpolation returns a string as result\nand an optional string which contains some error messages.",
            "title": "The interpolation"
        },
        {
            "location": "/codegen/#the-4-primitives-in-template",
            "text": "The  data  could be in the form of  foo.bar.baz .",
            "title": "The 4 primitives in template"
        },
        {
            "location": "/codegen/#1-attribute-reference",
            "text": "The syntax is  ${data[; separator='sep'][; format=name]} .  An undefined  data  produces an empty string.  The option  format  allows to specify a formatter function,\nwhich is a value of the template referred by the key  name .\nThe default behavior is given by the standard Lua function  tostring .  When  data  is a table, the option  separator  is used\nas parameter of  table.concat(data, sep) .\nThis parameter could be simple quoted or double quoted,\nand it handles escape sequence like Lua.\nThe characters  {  and  }  are forbidden,\nthere must be represented by a decimal escape sequence  \\ddd .  local CodeGen = require 'CodeGen'\n\ntmpl = CodeGen {\n    call = \"${name}(${parameters; separator=', '});\",\n}\ntmpl.name = 'print'\ntmpl.parameters = { 1, 2, 3 }\noutput = tmpl 'call'\nprint(output) --> print(1, 2, 3);",
            "title": "1. Attribute reference"
        },
        {
            "location": "/codegen/#2-template-include",
            "text": "The syntax is  ${name()}  where  name  is the keyname of a chunk template.  If  name  is not the keyname of a valid chunk,\nthere are no substitution and an error is reported.",
            "title": "2. Template include"
        },
        {
            "location": "/codegen/#3-conditional-include",
            "text": "The  if  syntax is  ${data?name1()} \nand the  if/else  syntax is  ${data?name1()!name2()} \nwhere  name1  and  name2  are the keyname of a chunk template\nand  data  is evaluated as a boolean.",
            "title": "3. Conditional include"
        },
        {
            "location": "/codegen/#4-template-application",
            "text": "The syntax is  ${data/name()[; separator='sep']} \nwhere  data  must be a table.\nThe template  name  is called for each item of the array  data ,\nand the result is concatened with an optional  separator .  The template has a direct access in the item,\nand inherits access from the caller.\nIf the item is not a table, it is accessible via the key  it .",
            "title": "4. Template application"
        },
        {
            "location": "/codegen/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/codegen/#99-bottles-of-beer",
            "text": "Yet another generation of the song 99 Bottles of Beer .  local CodeGen = require 'CodeGen'\n\nlocal function bootle (n)\n    if n == 0 then\n        return 'No more bottles of beer'\n    elseif n == 1 then\n        return '1 bottle of beer'\n    else\n        return tostring(n) .. ' bottles of beer'\n    end\nend\n\nlocal function action (n)\n    if n == 0 then\n        return 'Go to the store and buy some more'\n    else\n        return 'Take one down and pass it around'\n    end\nend\n\nlocal function populate ()\n    local t = {}\n    for i = 99, 0, -1 do\n        table.insert(t, i)\n    end\n    return t\nend\n\nlocal tmpl = CodeGen {\n    numbers = populate(),       -- { 99, 98, ..., 1, 0 }\n    lyrics = [[\n${numbers/stanza(); separator='\\n'}\n]],\n    stanza = [[\n${it; format=bootle} on the wall, ${it; format=bootle_lower}.\n${it; format=action}, ${it; format=bootle_next} on the wall.\n]],\n    bootle = bootle,\n    bootle_lower = function (n)\n        return bootle(n):lower()\n    end,\n    bootle_next = function (n)\n        return bootle((n == 0) and 99 or (n - 1)):lower()\n    end,\n    action = action,\n}\n\nprint(tmpl 'lyrics')            -- let's sing the song",
            "title": "99 Bottles of Beer"
        },
        {
            "location": "/codegen/#java-class",
            "text": "Java getter/setter generation with external template:  -- file: java.tmpl\n\nreturn require'CodeGen'{\n    class = [[\npublic class ${_name} {\n    ${_attrs/decl()}\n\n    ${_attrs/getter_setter(); separator='\\n'}\n}\n]],\n    decl = [[\nprivate ${_type} ${_name};\n]],\n    getter_setter = [[\npublic void set${_name; format=firstuc}(${_type} ${_name}) {\n    this.${_name} = ${_name};\n}\npublic ${_type} get${_name; format=firstuc}() {\n    return this.${_name};\n}\n]],\n    firstuc = function (s)\n        return s:sub(1, 1):upper() .. s:sub(2)\n    end,\n}  local tmpl = dofile 'java.tmpl' -- load the template\n\n-- populate with data\ntmpl._name = 'Person'\ntmpl._attrs = {\n    { _name = 'name',       _type = 'String' },\n    { _name = 'age',        _type = 'Integer' },\n    { _name = 'address',    _type = 'String' },\n}\n\nprint(tmpl 'class')     -- interpolation  The output is :  public class Person {\n    private String name;\n    private Integer age;\n    private String address;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return this.name;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n    public Integer getAge() {\n        return this.age;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n    public String getAddress() {\n        return this.address;\n    }\n}",
            "title": "Java class"
        },
        {
            "location": "/codegen/#rockspec",
            "text": "A generic template for rockspec.  -- file: rockspec.tmpl\nreturn CodeGen {\n    rockspec = [[\npackage = '${name}'\nversion = '${version}-${revision}'\n${_source()}\n${_description()}\n${_dependencies()}\n]],\n    _source = [[\nsource = {\n    url = ${_url()},\n    md5 = '${md5}',\n    dir = '${name}-${version}',\n},\n]],\n    _description = [[\ndescription = {\n    ${desc.summary?_summary()}\n    ${desc.homepage?_homepage()}\n    ${desc.maintainer?_maintainer()}\n    ${desc.license?_license()}\n},\n]],\n    _summary = 'summary = \"${desc.summary}\",',\n    _homepage = 'homepage = \"${desc.homepage}\",',\n    _maintainer = 'maintainer = \"${desc.maintainer}\",',\n    _license = 'license = \"${desc.license}\",',\n    _dependencies = [[\ndependencies = {\n${dependencies/_depend()}\n}\n]],\n    _depend = [[\n    '${name} >= ${version}',\n]],\n}  A specialization for all my projects.  -- file: my_rockspec.tmpl\nlocal parent = dofile 'rockspec.tmpl'\n\nreturn CodeGen({\n    lower = string.lower,\n    _tarball = \"${name; format=lower}-${version}.tar.gz\",\n    _url = \"'http://cloud.github.com/downloads/fperrad/${name}/${_tarball()}'\",\n    _homepage = 'homepage = \"http://fperrad.github.com/${name}\",',\n    desc = {\n        homepage = true,\n        maintainer = \"Francois Perrad\",\n        license = \"MIT/X11\",\n    },\n}, parent)  And finally, an use for this project.  CodeGen = require 'CodeGen'\n\nlocal rs = dofile 'my_rockspec.tmpl'\nrs.name = 'lua-CodeGen'\nrs.version = '0.1.0'\nrs.revision = 1\nrs.md5 = 'XxX'\nrs.desc.summary = \"a template engine\"\nrs.dependencies = {\n    { name = 'lua', version = 5.1 },\n    { name = 'lua-testmore', version = '0.2.1' },\n}\nprint(rs 'rockspec')  The output is :  package = 'lua-CodeGen'\nversion = '0.1.0-1'\nsource = {\n    url = 'http://cloud.github.com/downloads/fperrad/lua-CodeGen/lua-codegen-0.1.0.tar.gz',\n    md5 = 'XxX',\n    dir = 'lua-CodeGen-0.1.0',\n},\ndescription = {\n    summary = \"a template engine\",\n    homepage = \"http://fperrad.github.com/lua-CodeGen\",\n    maintainer = \"Francois Perrad\",\n    license = \"MIT/X11\",\n},\ndependencies = {\n    'lua >= 5.1',\n    'lua-testmore >= 0.2.1',\n}",
            "title": "Rockspec"
        },
        {
            "location": "/graph/",
            "text": "CodeGen.Graph\n\n\n\n\nReference\n\n\nThis module produces the call tree between chunks of a template.\n\n\nIt is useful to find orphan chunk.\n\n\nFunctions\n\n\nto_dot( tmpl )\n\n\nReturns a string in\n\nDOT\n format.\n\n\nExamples\n\n\n$ lua -e \"print(require 'CodeGen.Graph'.to_dot(require 'CodeGen.Graph'.template))\" > graph.dot\n$ dot -T png -o graph.png graph.dot\n\n\n\n\n$ cat graph.dot\ndigraph {\n    node [ shape = none ];\n\n    _node;\n    TOP;\n    _edge;\n\n    TOP -> _node;\n    TOP -> _edge;\n}",
            "title": "CodeGen.Graph"
        },
        {
            "location": "/graph/#codegengraph",
            "text": "",
            "title": "CodeGen.Graph"
        },
        {
            "location": "/graph/#reference",
            "text": "This module produces the call tree between chunks of a template.  It is useful to find orphan chunk.",
            "title": "Reference"
        },
        {
            "location": "/graph/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/graph/#to_dot-tmpl",
            "text": "Returns a string in DOT  format.",
            "title": "to_dot( tmpl )"
        },
        {
            "location": "/graph/#examples",
            "text": "$ lua -e \"print(require 'CodeGen.Graph'.to_dot(require 'CodeGen.Graph'.template))\" > graph.dot\n$ dot -T png -o graph.png graph.dot  $ cat graph.dot\ndigraph {\n    node [ shape = none ];\n\n    _node;\n    TOP;\n    _edge;\n\n    TOP -> _node;\n    TOP -> _edge;\n}",
            "title": "Examples"
        },
        {
            "location": "/lpeg/",
            "text": "CodeGen.lpeg\n\n\n\n\nReference\n\n\nJust an alternate implementation using\n\nLPeg\n\n(instead of pattern matching from \n\nstring\n library).\n\n\nExamples\n\n\nlocal CodeGen = require 'CodeGen.lpeg'\n\ntmpl = CodeGen {    -- instanciation\n    tarball = \"${name}-${version}.tar.gz\",\n    name = 'lua',\n}\ntmpl.version = 5.1\noutput = tmpl 'tarball'     -- interpolation\nprint(output) --> lua-5.1.tar.gz",
            "title": "CodeGen.lpeg"
        },
        {
            "location": "/lpeg/#codegenlpeg",
            "text": "",
            "title": "CodeGen.lpeg"
        },
        {
            "location": "/lpeg/#reference",
            "text": "Just an alternate implementation using LPeg \n(instead of pattern matching from  string  library).",
            "title": "Reference"
        },
        {
            "location": "/lpeg/#examples",
            "text": "local CodeGen = require 'CodeGen.lpeg'\n\ntmpl = CodeGen {    -- instanciation\n    tarball = \"${name}-${version}.tar.gz\",\n    name = 'lua',\n}\ntmpl.version = 5.1\noutput = tmpl 'tarball'     -- interpolation\nprint(output) --> lua-5.1.tar.gz",
            "title": "Examples"
        }
    ]
}